<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Building Climber</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Vital for mobile */
            user-select: none;
        }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 20px; text-shadow: 1px 1px 2px black; color: #fff;}
        p { margin: 5px 0; font-size: 14px; color: #aaa; text-shadow: 1px 1px 2px black;}
    </style>
</head>
<body>

<div id="ui">
    <h1 id="score">Height: 0</h1>
    <p>1. HOLD to Aim (Line sweeps)</p>
    <p>2. RELEASE to Jump</p>
    <p>3. HOLD while falling to Stick</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration ---
    let width, height;
    const gravity = 0.45;
    const friction = 0.98;
    const jumpPower = 18; 
    
    // --- Game State ---
    let cameraY = 0;
    let score = 0;
    let gameOver = false;
    let buildings = [];
    let buildingSpawnerY = 0; // Where to spawn the next building
    let aimAngle = -Math.PI / 2; // Starts pointing up
    let aimDirection = 1; // 1 = moving right, -1 = moving left

    // --- Input ---
    const input = { isDown: false };

    // --- The Ball ---
    const ball = {
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        radius: 10,
        isStuck: true,
        stuckObject: null, // Reference to the rect we are stuck to
        color: '#00ffcc'
    };

    // --- Initialization ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        if (buildings.length === 0) resetGame();
    }

    function resetGame() {
        cameraY = 0;
        score = 0;
        gameOver = false;
        
        // Setup Ball
        ball.radius = 10;
        ball.x = width / 2;
        ball.y = height - 100;
        ball.vx = 0;
        ball.vy = 0;
        ball.isStuck = true;
        ball.stuckObject = null;
        ball.color = '#00ffcc';

        // Setup Buildings
        buildings = [];
        buildingSpawnerY = height; // Start spawning from bottom
        
        // Create a floor
        buildings.push({
            x: -50, y: height - 20, w: width + 100, h: 100, color: '#444'
        });

        // Generate initial set
        generateBuildings(height - 20);
    }

    // --- Building Generation ---
    function generateBuildings(startY) {
        // Generate buildings upwards (negative Y)
        while (buildingSpawnerY > startY - height * 2) { // Keep buffer above screen
            buildingSpawnerY -= (100 + Math.random() * 80); // Gap between buildings
            
            let bWidth = 60 + Math.random() * 150;
            let bHeight = 40 + Math.random() * 100;
            let bX = Math.random() * (width - bWidth);
            
            buildings.push({
                x: bX,
                y: buildingSpawnerY,
                w: bWidth,
                h: bHeight,
                color: '#555'
            });
        }
        
        // Remove buildings way below camera to save memory
        buildings = buildings.filter(b => b.y - cameraY < height + 500);
    }

    // --- Input Handling ---
    function handleStart() {
        if (gameOver) { resetGame(); return; }
        input.isDown = true;
    }
    
    function handleEnd() {
        input.isDown = false;
        // If we were stuck and aiming, FIRE!
        if (ball.isStuck) {
            launchBall();
        }
    }

    window.addEventListener('mousedown', handleStart);
    window.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(); }, {passive:false});
    canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleEnd(); }, {passive:false});

    // --- Logic ---

    function launchBall() {
        ball.isStuck = false;
        ball.stuckObject = null;
        ball.color = '#ffeb3b'; // Yellow (Flying)
        
        ball.vx = Math.cos(aimAngle) * jumpPower;
        ball.vy = Math.sin(aimAngle) * jumpPower;
    }

    function checkCollision(rect) {
        // Simple AABB collision detection (Circle vs Rect)
        // Find closest point on the rectangle to the center of the circle
        let testX = ball.x;
        let testY = ball.y;

        if (ball.x < rect.x) testX = rect.x;      // Test left edge
        else if (ball.x > rect.x + rect.w) testX = rect.x + rect.w;   // right edge
        
        if (ball.y < rect.y) testY = rect.y;      // top edge
        else if (ball.y > rect.y + rect.h) testY = rect.y + rect.h;   // bottom edge

        let distX = ball.x - testX;
        let distY = ball.y - testY;
        let distance = Math.sqrt((distX*distX) + (distY*distY));

        return distance <= ball.radius;
    }

    function update() {
        if (gameOver) return;

        // 1. Aim Oscillation
        // If holding input, sweep aim from 180 (PI) to 360 (2PI) roughly
        // We want -10 deg to -170 deg
        if (input.isDown) {
            const speed = 0.08;
            aimAngle += speed * aimDirection;
            
            // Bounds for aiming (Only upwards arc)
            if (aimAngle > -0.2) { aimAngle = -0.2; aimDirection = -1; }
            if (aimAngle < -Math.PI + 0.2) { aimAngle = -Math.PI + 0.2; aimDirection = 1; }
        }

        // 2. Physics
        if (!ball.isStuck) {
            ball.vy += gravity;
            ball.vx *= friction; // Air resistance
            ball.vy *= friction;
            
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Wall Collisions (Screen Edges)
            if (ball.x < ball.radius) { ball.x = ball.radius; ball.vx *= -0.5; }
            if (ball.x > width - ball.radius) { ball.x = width - ball.radius; ball.vx *= -0.5; }

            // Building Collisions
            if (input.isDown) { // ONLY stick if holding input
                for (let b of buildings) {
                    if (checkCollision(b)) {
                        ball.isStuck = true;
                        ball.vx = 0;
                        ball.vy = 0;
                        ball.stuckObject = b;
                        ball.color = '#00ffcc'; // Green (Stuck)
                        break;
                    }
                }
            }
        } else {
            // If Stuck: Move with the object? (Not needed for static blocks)
            // But we must clamp ball to the edge surface if needed?
            // For this simple version, simply stopping velocity is enough visual feedback.
        }

        // 3. Camera & World Generation
        // Move camera if ball goes high
        const targetY = ball.y - height * 0.6;
        if (targetY < cameraY) {
            cameraY += (targetY - cameraY) * 0.1;
        }
        // Also move camera slowly down if we fall? No, let's keep it climbing only.
        
        // Generate new buildings based on camera
        generateBuildings(cameraY);

        // Score
        let currentHeight = Math.floor(Math.abs(ball.y - (height - 100)) / 10);
        if (currentHeight > score) score = currentHeight;

        // Death
        if (ball.y - cameraY > height + 100) {
            gameOver = true;
        }
    }

    // --- Rendering ---
    function draw() {
        // Background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);

        ctx.save();
        ctx.translate(0, -cameraY);

        // Draw Buildings
        ctx.fillStyle = '#666';
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        for (let b of buildings) {
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.strokeRect(b.x, b.y, b.w, b.h);
        }

        // Draw Aim Line
        if (input.isDown && ball.isStuck) {
            ctx.beginPath();
            ctx.moveTo(ball.x, ball.y);
            ctx.lineTo(ball.x + Math.cos(aimAngle) * 100, ball.y + Math.sin(aimAngle) * 100);
            ctx.strokeStyle = '#ff0055';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // Draw Ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = ball.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        // UI
        document.getElementById('score').innerText = `Height: ${score}`;
        
        if (gameOver) {
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = '30px Courier';
            ctx.fillText("FALLEN", width/2, height/2);
            ctx.font = '16px Courier';
            ctx.fillText("Tap to Restart", width/2, height/2 + 30);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    resize();
    loop();

</script>
</body>
</html>
